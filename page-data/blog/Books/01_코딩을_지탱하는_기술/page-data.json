{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/Books/01_코딩을_지탱하는_기술/",
    "result": {"data":{"markdownRemark":{"html":"<blockquote>\n<p>프로그래밍 언어에는 다양한 개념이 왜 존재하고, 이런 개념들은 왜 탄생한 것일까? 이 책의 목적은 그 ‘왜'를 알아내는 것이다.</p>\n</blockquote>\n<p><strong>이 책을 읽는 목적</strong></p>\n<ul>\n<li>프로그래밍 언어에서 새로운 개념이 점차 등장하며 복잡해져 간 과정을 따라감으로써, 어떤 이유로 해당 기능이 필요했는지 깨우친다. 그 필요성과 쓰임새를 알게 됨으로써 비로소 어떻게 하면 잘 쓸 수 있는지 깨우치는 것이 목표이다.</li>\n</ul>\n<h2>4장 처리 흐름 제어</h2>\n<p><strong>while 문과 for 문</strong></p>\n<ul>\n<li>for 문을 사용하면 한 곳에서 세 개의 조건을 모두 확인할 수 있기 때문에 루프의 의도를 쉽게 파악할 수 있다.</li>\n<li>함수형 프로그래밍에서 설계자의 코딩 목적을 명확히 이해해야 그것을 제 목적에 위배되지 않도록 적재적소에 활용할 수 있다.</li>\n</ul>\n<h2>5장 함수</h2>\n<ul>\n<li>함수가 가져다준 이점은 크게 <strong>(1) 코드의 직관적 파악, (2) 재사용성 &#x26; 재귀 호출</strong>이 있다. 책에서는 함수를 이래와 같이 말한다.</li>\n</ul>\n<blockquote>\n<p>코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능</p>\n</blockquote>\n<ul>\n<li>함수는 호출해서 쓰이기 위해 만들어진다.</li>\n</ul>\n<p><strong>재귀 호출</strong></p>\n<ul>\n<li>함수는 재사용이 가능하므로, 재귀 호출을 통해서 구현하면 내포(nesting)형태의 처리를 구현할 수 있으며, 이때 호출하는 함수의 구조 또한 유사하게 nesting 된 구조로 실행하는 경우가 많다.</li>\n</ul>\n<p><strong>요약</strong></p>\n<blockquote>\n<p>한 그룹인 코드를 배내어 의미있는 이름을 붙여서, 그 코드가 무엇을 하고 있는지 파악하기 쉬워진다. 그리고 그 함수를 다른 장소에서 호출하여 사용함으로 재사용도 가능해진다.\n또한 함수를 사용함으로 ‘재귀 호출'이라는 코딩 기술이 탄생했다.</p>\n</blockquote>\n<h2>알게 된 점</h2>\n<p>무엇이 더 나은 코드인지 고민하는 기준은 주관적이다. 프로그래밍 언어가 발전해온 ‘역사'와 그것이 가져다준 이익을 따라감으로써 더 나은 코드의 요건을 어렴풋이 알 수 있었다. <strong>코드 작성자의 의도, 코드가 무슨 일을 하는지 (역할), 왜 하는지 (목적)을</strong> 명확히 파악할 수 있는 것이 좋은 코드이다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"코딩을 지탱하는 기술 (1)","desc":"1~5장을 읽고","thumbnail":null,"date":"2022-09-12","category":"TIL"}}},"pageContext":{"slug":"/blog/Books/01_코딩을_지탱하는_기술/"}},
    "staticQueryHashes": ["1840460387"]}