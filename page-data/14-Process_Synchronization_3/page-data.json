{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/14-Process_Synchronization_3/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"940fce04-e385-59d7-b835-0fec8f91292b","excerpt":"Semaphores, Implementation, Classical Problems of Syncronization, Bounded-Buffer Problem, Readers-Writers Problem, Dining-Philosophers Problem, Monitor…","html":"<blockquote>\n<p>Semaphores, Implementation, Classical Problems of Syncronization, Bounded-Buffer Problem, Readers-Writers Problem, Dining-Philosophers Problem, Monitor</p>\n</blockquote>\n<h1>Classical Problems of Synchronization</h1>\n<ol>\n<li>Bounded Buffer Problem</li>\n<li>Readers and Writers Problem</li>\n<li>Dining-Philosophers Problem</li>\n</ol>\n<h2>01 Bounded Buffer Problem</h2>\n<h3><strong>Bounded Buffer</strong></h3>\n<ul>\n<li>버퍼: 임시 데이터 저장공간, 크기가 유한함</li>\n<li>2가지 종류의 프로세스: producer, consumer 각각 여러 개\n<ul>\n<li><strong>Producer, 생산자:</strong> 공유 버퍼에 데이터 만들어서 집어넣는 역할</li>\n<li><strong>Consumer, 소비자:</strong> 데이터를 꺼내가는 역할</li>\n</ul>\n</li>\n</ul>\n<h3>Synchronization 문제 예시</h3>\n<ol>\n<li><strong>공유 데이터 접근</strong>\n<ul>\n<li>공유 버퍼에 생산자가 동시에 도착하는 경우?\n<ul>\n<li>비어 있는 버퍼를 확인하고, 데이터를 만들어 집어넣는 과정에 lock &#x26; unlock 필요</li>\n</ul>\n</li>\n<li>소비자가 동시에 도착하는 경우?\n<ul>\n<li>lock &#x26; unlock 필요</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Bounded (유한) 문제\n<ul>\n<li>생산자 입장에서의 자원: 비어있는 버퍼의 개수</li>\n<li>소비자 입장에서의 자원: 내용이 있는 자원의 개수</li>\n<li>문제 예시\n<ul>\n<li>생산자가 도착해서 공유 버퍼가 다 찼는데 또 생산자가 도착하는 경우\n<ul>\n<li>꽉 찬 버퍼 → 생산자 입장에서는 available 자원이 없다.</li>\n</ul>\n</li>\n<li>소비자가 도착해서 내용을 다 꺼내갔는데 또 소비자가 도착하는 경우\n<ul>\n<li>빈 버퍼 → 소비자 입장에서는 available 자원이 없다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>따라서, 두 가지 문제를 위한 semaphore 변수 필요</li>\n</ul>\n<h3>Semaphore: Synchronization Variables</h3>\n<ol>\n<li><strong>mutual exclusion:</strong> 동시 접근을 막기 위한 lock &#x26; unlock</li>\n<li><strong>resource count:</strong> 꽉 차거나 비었을 때 가용자원의 개수를 세는 counting Semaphore\n<ul>\n<li>내용이 들어있는 버퍼의 개수를 조정하는 변수: 남은 full/empty buffer의 개수 조정</li>\n</ul>\n</li>\n</ol>\n<h3>구조</h3>\n<ol>\n<li>버퍼 확인</li>\n<li>있으면 lock / 없으면 기다리기</li>\n<li>empty / full 버퍼 접근, 조작</li>\n<li>Unlock</li>\n<li>full/empty 버퍼 개수 증가</li>\n</ol>\n<h2>02 Readers-Writers Problem</h2>\n<ul>\n<li>이 문제에서는\n<ul>\n<li>공유 데이터 == DB</li>\n<li>process: DB에 읽고 쓰는 프로세스</li>\n</ul>\n</li>\n<li>Lock / Unlock 활용한 구현</li>\n</ul>\n<h3>작업 간 차이점</h3>\n<ul>\n<li>Writers: 동시에 쓸 수 <strong>없음</strong></li>\n<li>Readers: 동시에 읽을 수 <strong>있음!</strong></li>\n<li>따라서 읽는 건 동시에 작업 가능하도록 구현하는 것이 더 바람직하다 😆\n<ul>\n<li>→ 단순하게 항상 P연산 lock - V연산 unlock 보다 효율적</li>\n</ul>\n</li>\n</ul>\n<h3>코드 구조</h3>\n<ul>\n<li>공유 데이터 <strong>db, mutex</strong> ← binary Semaphore 사용해서 P, V연산 구현</li>\n<li>공유 변수 <strong>readcount</strong>: DB를 읽고 있는 reader의 개수\n<ul>\n<li><code class=\"language-text\">(readcount == 1)</code> → P(db)</li>\n<li><code class=\"language-text\">(readcount == 0)</code> → V(db)</li>\n</ul>\n<h3>binary Semaphore used</h3>\n<ul>\n<li><strong>db</strong>\n<ul>\n<li>DB에 대한 lock, unlock</li>\n</ul>\n</li>\n<li><strong>mutex</strong>\n<ul>\n<li>readcount 변수에 대한 lock, unlock</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Starvation</h3>\n<ul>\n<li>문제점\n<ul>\n<li>Starvation: reader 처리로 인해 writer가 오랫동안 기다려야만 하는 상황 발생 가능성</li>\n<li>그렇다고 순서대로 처리하면 비효율적인 알고리즘이 된다.</li>\n</ul>\n</li>\n<li>해결\n<ul>\n<li>해당 코드 내에서는 중간에 빠져나가서 unlock 하고 writer 가 들어올 수 있게끔 적당한 정도에서 끊어주는 방식으로 구현할 수 있다. (해당 예제)</li>\n<li>그 외에도 여러 개선 방향이 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>03 Dining-Philosophers Problem</h2>\n<ul>\n<li>양쪽 젓가락을 잡아야만 밥을 먹을 수 있는 문제</li>\n<li>하나의 공유 자원(한쪽 젓가락)을 동시에 두 명이 잡을 수 없다.</li>\n</ul>\n<h3>Deadlock</h3>\n<ul>\n<li>모든 철학자가 동시에 왼쪽 젓가락을 잡았으면, 배가 부를 때까지 놓지 못하는데 - 이 경우 아무도 오른쪽 젓가락을 잡을 수 없다.</li>\n<li>deadlock 해결책\n<ul>\n<li>n명의 철학자만이 동시에 테이블에 앉을 수 있도록 한다.</li>\n<li>양쪽 젓가락을 잡을 수 있는 경우에만 권한을 준다.</li>\n<li>젓가락 간 우선순위 부여\n<ul>\n<li>짝수 - 왼쪽, 홀수 - 오른쪽 젓가락부터 잡도록 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Monitor</h1>\n<ul>\n<li>Semaphore 의 어려움\n<ul>\n<li>실수가 치명적이며, 디버깅, 실수 검증이 어렵다.</li>\n<li>→ 한 치의 실수 없이 항상 정확한 코딩이 요구되는 까다로움!</li>\n<li>⇒ 이 문제를 보다 쉽고 편리하게 구현한 Monitor</li>\n</ul>\n</li>\n<li>Monitor: 프로그래밍 언어 차원에서 문제의 해결을 목표로 하는 high-level synchronization constructure\n<ul>\n<li>내부에 공유 데이터를 선언하고, 내부 함수를 통해 접근할 수 있다.\n<ul>\n<li>따라서 내부에 정의되어 있으므로 해당 Monitor 내부 procedure 를 통해서만 내부 공유데이터에 접근할 수 있다.</li>\n<li>모니터 내부의 procedure은 동시에 수행될 수 없다.\n<ul>\n<li>→ 그러므로 직접 <strong>lock을 걸고 풀 필요가 없다! ⭐️</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Semaphore과의 차이점\n<ul>\n<li>Lock을 걸 필요가 없다</li>\n<li>이해가 쉽다</li>\n</ul>\n</li>\n<li>condition variable\n<ul>\n<li>semaphore 변수와 유사한 역할</li>\n<li><strong>구현:</strong> 자원의 여분이 있으면 주고 / 없으면 변수를 기다리게 하는 함수를 정의 / 빠져나가면 signal 호출로 빠져나갈 수 있도록 구현</li>\n</ul>\n</li>\n<li>monitor 안에서는 하나의 프로세스만 활성화되므로\n<ul>\n<li>변수가 queue에 줄 서 있는 프로세스를 넣고, 깨워주고의 역할\n<ul>\n<li>큐에 줄 서서 기다리면 잠들었다 - 큐에 줄 서 있는 프로세스를 하나 깨워주기</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[KOCW] 운영체제 (반효경, 2014) - 14. Process Synchronization 3","date":"March 02, 2022","description":"Classical Problems of Synchronization: Bounded Buffer Problem, Readers-Writers Problem, Dining-Philosophers Problem // Monitor"}},"previous":{"fields":{"slug":"/BOJ-3055/"},"frontmatter":{"title":"[boj] 3055. 탈출 (node.js)"}},"next":{"fields":{"slug":"/BOJ-1916/"},"frontmatter":{"title":"[boj] 1916. 최소비용 구하기 (node.js)"}}},"pageContext":{"id":"940fce04-e385-59d7-b835-0fec8f91292b","previousPostId":"7c33dbd0-02ac-5b31-8757-302f55e24798","nextPostId":"b5dedf4d-aa52-55e1-816d-57294dd78801"}},
    "staticQueryHashes": ["230163734","2841359383"]}