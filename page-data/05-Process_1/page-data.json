{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/05-Process_1/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"f71028fc-1d3d-59f5-8d1c-e193bb49aec6","excerpt":"프로세스 프로세스: 실행 중인 프로그램 프로세스의 문맥: 특정 시점에서의 CPU 수행 상태를 나타내는 하드웨어 문맥 프로세스의 문맥 (Context) 프로세스의 상태를 알기 위해 필요한 모든 요소들을 뜻하며, 하드웨어 문맥: CPU 수행 상태 program counter…","html":"<h1>프로세스</h1>\n<ul>\n<li>프로세스: 실행 중인 프로그램</li>\n<li>프로세스의 문맥: 특정 시점에서의 CPU 수행 상태를 나타내는 하드웨어 문맥</li>\n</ul>\n<h2>프로세스의 문맥 (Context)</h2>\n<ul>\n<li>프로세스의 상태를 알기 위해 필요한 모든 요소들을 뜻하며,</li>\n<li>하드웨어 문맥: CPU 수행 상태\n<ul>\n<li>program counter (register)가 코드의 어디를 가리키는지 (수행 중인지),</li>\n<li>register</li>\n</ul>\n</li>\n<li>프로세스의 주소공간: code, data, stack\n<ul>\n<li>stack이 어느 정도 쌓였는지, 현재 data의 변수값,</li>\n</ul>\n</li>\n<li>운영체제; 커널 자료구조: PCB, Kernel Stack</li>\n<li>이와 같은 요소들을 통해 프로세스의 상태 -> 문맥을 알아낼 수 있다.</li>\n</ul>\n<h2>프로세스의 상태 (State)</h2>\n<ul>\n<li>프로세스는 상태가 변경되며 수행된다.</li>\n<li>running (CPU를 잡고 수행중)</li>\n<li>ready (기다리는 중, 다른 모든 준비 완료; CPU만 닫으면 되는 상태)</li>\n<li>blocked (wait, sleep)</li>\n<li>기타: new (생성중), terminated (종료중)</li>\n</ul>\n<h2>프로세스의 문맥 교환 (Context Switch)</h2>\n<ul>\n<li><code class=\"language-text\">프로세스 A</code> -> <code class=\"language-text\">프로세스 B</code>로 CPU를 넘겨주는 것</li>\n<li>CPU가 프로세스 간에 넘어갈 때, <strong>운영체제</strong>는 <strong>PCB</strong>에\n<ul>\n<li>(내어주는 프로세스의 상태는) 저장하고,</li>\n<li>(새롭게 얻을 프로세스의 상태는) 읽어옴</li>\n</ul>\n</li>\n<li>유의:\n<ul>\n<li>system call 또는 interrupt 발생이 항상 문맥 교환인 것은 아님!</li>\n<li>타 프로그램에 넘기기 위한 의도로 timer interrupt 하는 것 -> Context Switch (O)</li>\n</ul>\n</li>\n</ul>\n<h1>Scheduler</h1>\n<ul>\n<li>Short-term: CPU Scheduler, 프로세스에 <strong>CPU를</strong> 주는 문제.\n<ul>\n<li>running 할 다음 프로세스를 결정</li>\n<li>단시간 단위(millisecond).</li>\n</ul>\n</li>\n<li>Long-term: Job Scheduler, 프로세스에 <strong>Memory를</strong> 주는 문제.\n<ul>\n<li>메모리 admit(new -> ready) 여부를 결정</li>\n<li>보통 시분할 시스템에는 없음 => Medium-term!</li>\n</ul>\n</li>\n<li>Medium-term: Swapper, 프로세스에서 <strong>메모리를 뺏는</strong> (디스크로 쫓아내는) 문제.\n<ul>\n<li>메모리에 너무 많이 올라가 있으면 여유공간 마련을 위해 프로세스를 통째로 메모리 -> 디스크로 쫓아내기</li>\n<li>degree of multiprogramming: 메모리에 올라간 프로세스의 수 제어</li>\n<li>suspended 상태: 메모리를 뺏겨서 정지되어 디스크에 swap-out된 상태. 더이상의 CPU 작업은 진행되지 않음.</li>\n</ul>\n</li>\n<li>Blocked vs Suspended\n<ul>\n<li>Blocked: 요청작업 정지, 끝나면 ready 가능.</li>\n<li>Suspended: 외부에서 정지(inactive), 외부에서 active 재개해줘야 작업으로 돌아갈 수 있다.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>cf. 표현법 주의: 사용자 프로세스가 운영체제 커널에서 수행되고 있다. (O)\n<ul>\n<li>운영체제가 running (X)\n<ul>\n<li>‘상태’는 운영체제의 상태가 아닌 Process의 상태를 가리킨다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[KOCW] 운영체제 (반효경, 2014) - 5. Process1","date":"February 13, 2022","description":"Process: 문맥, 상태, 문맥 교환, 스케줄러"}},"previous":{"fields":{"slug":"/BOJ-2470/index02/"},"frontmatter":{"title":"[boj] 2470. 두 용액 (node.js)"}},"next":{"fields":{"slug":"/BOJ-16472/"},"frontmatter":{"title":"[boj] 16472. 고냥이 (node.js)"}}},"pageContext":{"id":"f71028fc-1d3d-59f5-8d1c-e193bb49aec6","previousPostId":"0711c974-9f0c-55f2-a8f5-ee463d081e73","nextPostId":"8341a511-2f35-50f0-ab1c-657e56bd30d2"}},
    "staticQueryHashes": ["230163734","2841359383"]}