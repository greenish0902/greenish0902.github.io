{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/09-Process_Management_2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"a57d4bf1-bae9-501b-98bb-ebc3aff8b5c5","excerpt":"프로세스 생성(Process Creation), 프로세스와 관련한 시스템콜, 프로세스 간 협력, Message Passing, Interprocess communication, CPU and I/O Bursts in Program Execution, CPU-burst Time…","html":"<blockquote>\n<p>프로세스 생성(Process Creation), 프로세스와 관련한 시스템콜, 프로세스 간 협력, Message Passing, Interprocess communication, CPU and I/O Bursts in Program Execution, CPU-burst Time의 분포, 프로세스의 특성 분류, CPU Scheduler &#x26; Dispatcher</p>\n</blockquote>\n<h1>프로세스 생성</h1>\n<ul>\n<li><strong>COW: Copy-on-Write 기법</strong>\n<ul>\n<li>운영체제, 메모리 관리, 파일시스템에 자주 등장하는 개념</li>\n<li>write가 발생했을 때 copy 하겠다는 의미로, 내용이 바뀔 때 (부모의 code, data, stack은 잘게 쪼개진 형태 - 이 쪼개진 것들 중 필요한 것만) copy해서 새로운 것을 만들고, 그 이전까지는 부모의 것을 그대로 공유하고 있는 것</li>\n</ul>\n</li>\n</ul>\n<h3>fork() 시스템 콜</h3>\n<ul>\n<li>\n<p>fork: 새로운 프로세스를 만드는 시스템 콜, 운영체제에 새로운 프로세스를 만들어 달라는 요청.</p>\n</li>\n<li>\n<p>일단 복제생성하고 exec로 추후 필요한 부분을 덮어씌우게 됨.</p>\n</li>\n<li>\n<p>fork의 결과로 프로세스가 생성됨.</p>\n</li>\n<li>\n<p>부모 프로세스의 문맥 (context, 즉 program counter)을 그대로 복사함. 즉 처음부터가 아니라 부모 프로세스에서 실행한 다음부터 실행이 이어지는 것.</p>\n</li>\n<li>\n<p><strong>구분: 부모 프로세스는 fork의 결과값이 양수, 자식 프로세스는 fork의 결과값이 0이다.</strong></p>\n<ul>\n<li>부모 프로세스와 자식 프로세스 간 구분이 어려우므로, 혼란스러운 상황이 생김. → 이를 구분하기 위해 반환하는 값에 차이를 둠.</li>\n<li>그러므로 부모 - 자식 프로세스에 다른 일을 하도록 처리할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3>exec() 시스템 콜</h3>\n<ul>\n<li>프로그램을 새로운 프로세스로 시작하게 하는 역할.</li>\n<li>fork() 시스템 콜 → (복제) 자식 프로세스 → exec() 시스템 콜 → <strong>완전히 새로운 프로그램으로 다시 시작.</strong></li>\n<li>exec() 이후의 코드는 영원히 실행되지 않음.</li>\n<li>예시 <code class=\"language-text\">execlp(”echo”, “echo”, “3(char *)0)</code></li>\n</ul>\n<h3>wait() 시스템 콜</h3>\n<ul>\n<li>프로세스를 block 상태(잠들기)로 만듦\n<ul>\n<li>block: 오래 걸리는 작업에서 보통 block으로 sleep시켜두고</li>\n<li>작업이 끝나면 ready 상태로 돌아오게 함</li>\n</ul>\n</li>\n<li>자식 프로세스를 만든 다음에 종료될 때까지 block 했다가, 자식 프로세스가 끝나면 프로세스를 다시 깨워 ready 상태로 돌아오게 하는 것</li>\n</ul>\n<h3>exit() 시스템 콜</h3>\n<ul>\n<li>모든 자원을 반납하고 부모 프로세스에 죽는다고 알림</li>\n<li>자발적 종료: 마지막 문장 실행 후에 프로그램이 스스로 종료될 때</li>\n<li>비자발적 종료: 외부적 요인에 의한 강제 종료 (사람, 부모 프로세스)\n<ul>\n<li>부모 프로세스가 강제 종료시키는 경우</li>\n<li>사람이 키보드로 Ctrl + C, kill, break 등을 친 경우</li>\n<li>부모 프로세스가 종료된 경우; 프로세스의 규칙에 따라 계층적으로 자식이 먼저 죽게 됨</li>\n</ul>\n</li>\n</ul>\n<h1>프로세스 간 협력</h1>\n<ul>\n<li>\n<p>프로세스는 독립적이다. 원칙적으로 서로 영향을 미칠 수 없다.</p>\n</li>\n<li>\n<p>효율화를 위해 협력하기도 한다.</p>\n</li>\n<li>\n<p>IPC: 프로세스 간 협력 메커니즘</p>\n<ul>\n<li>\n<p><strong>(1) Message Passing:</strong> 사용자 프로세스 간에 직접 전달할 수 없으므로 운영체제 커널을 통해 전달</p>\n<ul>\n<li><strong>Direct</strong> Communication: 통신하려는 프로세스 이름을 명시</li>\n<li><strong>Indirect</strong> Communication: 수신자를 명시하지 않음, mailbox에 전달.</li>\n</ul>\n</li>\n<li>\n<p><strong>(2) Shared Memory:</strong> 일부 주소공간을 두 프로세스가 공유</p>\n<ul>\n<li>A, B 각자의 주소공간은 존재하나 이를 물리적 메모리 위에 매핑할 때 일부 메모리 공간을 공유.</li>\n<li>즉, 물리적 메모리 위에 프로세스 A, B가 공유하는 영역이 존재하는 셈.</li>\n<li>시스템 콜 → 커널을 통해 매핑(share)하게 한 후부터 두 프로세스 간 공유 작업이 가능\n<ul>\n<li>까다로운 작업이므로 두 프로세스 간의 신뢰관계 필요</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>cf. 스레드: 주소공간을 완전히 공유.</p>\n</li>\n</ul>","frontmatter":{"title":"반효경 [운영체제] 9. Process Management 2","date":"220218 Fri","description":"프로세스 생성, 시스템 콜, 프로세스 간 협력"}},"previous":{"fields":{"slug":"/BOJ-10816/"},"frontmatter":{"title":"[boj] 10816. 숫자 카드 2 (node.js)"}},"next":{"fields":{"slug":"/BOJ-1389/"},"frontmatter":{"title":"[boj] 1389. 케빈 베이컨의 6단계 법칙 (node.js)"}}},"pageContext":{"id":"a57d4bf1-bae9-501b-98bb-ebc3aff8b5c5","previousPostId":"1bf17096-79e1-5a83-bddc-fb1b50e62ea1","nextPostId":"f12dfb45-8e9c-5a79-959e-1e39a2d68a7c"}},
    "staticQueryHashes": ["230163734","2841359383"]}