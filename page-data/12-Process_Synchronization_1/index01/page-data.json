{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/12-Process_Synchronization_1/index01/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"adc2c932-d4a6-5e25-9fed-29782cb9f9ee","excerpt":"컴퓨터 시스템 데이터의 접근 일반적인 접근 데이터 저장된 위치에서 읽어와서 연산된 결과를 다시 위치에 저장(반영) 누가 먼저 읽어갔느냐에 따른 결과 변동 가능성 ⇒ Process Synchronization 문제 발생 관점 CPU…","html":"<h1>컴퓨터 시스템 데이터의 접근</h1>\n<h3>일반적인 접근</h3>\n<ol>\n<li>데이터 저장된 위치에서</li>\n<li>읽어와서</li>\n<li>연산된 결과를 다시 위치에 저장(반영)</li>\n</ol>\n<ul>\n<li>누가 먼저 읽어갔느냐에 따른 결과 변동 가능성</li>\n<li><strong>⇒ Process Synchronization 문제 발생</strong></li>\n</ul>\n<h3>관점</h3>\n<ul>\n<li>CPU - 메모리 간 접근: 읽어들여서 연산하고 다시 저장</li>\n<li>컴퓨터가 하드디스크 (IO장치)에 접근</li>\n<li>프로세스 - 주소공간 간 접근</li>\n</ul>\n<h3>Race Condition</h3>\n<ul>\n<li>메모리 주소를 공유하는 프로세스가 여러 개인 경우</li>\n<li>일반적으로 프로세스는 자기 주소공간을 가지므로 문제 발생 거의 없음, 그러나 운영체제 system call하는 경우 커널의 코드 실행: 데이터를 읽어서 루틴 수행. ⇒ Race Condition 문제</li>\n<li>커널의 코드 실행 중에 interrupt 가 발생하는 경우: 커널 실행 중 또 커널코드(interrupt) 실행하게 됨</li>\n</ul>\n<h1>Case of Race Condition</h1>\n<h3>Case 1: interrupt handler - kernel</h3>\n<ul>\n<li>커널의 데이터를 양쪽에서 건드리는 도중에 CPU 처리\n<ul>\n<li>커널모드 running 도중에 interrupt 가 발생하여 인터럽트 처리 루틴이 수행됨 → 양쪽 다 커널의 코드이므로 kernel address space를 공유하는 셈</li>\n</ul>\n</li>\n<li>해결 방안: 중요한 값 도중에는 interrupt 처리를 하지 않고, 처리 끝낸 후에 interrupt 하도록 해결</li>\n</ul>\n<h3>Case 2: CPU 할당 시간</h3>\n<ul>\n<li>할당된 시간이 끝난 시점에 프로세스는 system call로 커널 코드가 실행 중인 경우 → 또 다른 프로세스에서 또 커널 코드를 건드리게 되는 문제 발생</li>\n<li>해결: 커널 모드에 있을 때는 할당시간이 끝나도 CPU를 뺏기지 않도록 함.\n<ul>\n<li>커널 모드가 끝나고 user 모드로 나올 때 CPU 를 빼앗음.</li>\n<li>time sharing system은 realtime이 아니므로 약간의 시간 오차는 있겠지만 문제 해결이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<h3>Case 3: CPU가 여러 개인 환경</h3>\n<ul>\n<li>작업 주체 CPU가 여러 개이므로 앞선 방법처럼 interrupt 를 막는 방식으로 해결이 불가능함.</li>\n<li>해결: lock\n<ul>\n<li>(1) 개별 데이터에 대한 lock: 수정중인 데이터는 lock을 걸어서 더 이상 접근하지 못하도록 함. 추후 unlock.</li>\n<li>(2) 커널 접근에 대한 lock: 커널 전체를 하나의 lock으로 막고, 커널에서 나올 때 unlock\n<ul>\n<li>매우 비효율적; CPU는 여러 개이지만 한 번에 한 개의 CPU만 커널에 접근 가능하다는 한계</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Process Synchronization</h1>\n<ul>\n<li>공유 데이터 동시 접근은 데이터의 inconsistiency를 발생시킬 수 있다.</li>\n<li>협력 프로세스 간 실행 순서 정하는 mechanism이 필요하다.</li>\n<li>프로세스들이 동시에 공유 데이터에 접근하는 Race condition 상황의 발생을 막기 위해서 Synchronization 이 필요하다.</li>\n</ul>\n<h1>Critical Section</h1>\n<ul>\n<li>Critical Section (임계구역): 공유 데이터에 접근하는 코드를 뜻함</li>\n<li>코드는 임계구역인지 아닌지에 따라 분류 가능</li>\n<li>synchronization 문제 해결 위한 software적인 방법 (알고리즘) 이 존재 (다음 강의)</li>\n</ul>","frontmatter":{"title":"반효경 [운영체제] 12. Process Synchronization 1","date":"220224 Thu","description":"데이터 접근, race condition, critical section"}},"previous":{"fields":{"slug":"/BOJ-node-js/BOJ-1697/"},"frontmatter":{"title":"[boj] 1697. 숨바꼭질 (node.js)"}},"next":{"fields":{"slug":"/BOJ-node-js/BOJ-21919/"},"frontmatter":{"title":"[boj] 21919. 소수 최소 공배수 (node.js)"}}},"pageContext":{"id":"adc2c932-d4a6-5e25-9fed-29782cb9f9ee","previousPostId":"25e9adcc-69b4-5c33-88bb-dc53d1ed64b7","nextPostId":"09c500d1-5f38-5d95-9153-86807c4b34f9"}},
    "staticQueryHashes": ["230163734","2841359383"]}