{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/18-Memory_Management_1/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"380b914b-b278-5e80-b2ef-92e45fe1f7e1","excerpt":"Logical vs. Physical Address, 주소바인딩(Address Binding), Memory-Management Unit(MMU), Dynamic Relocation, Hadware Support for Address Translation, Some…","html":"<blockquote>\n<p>Logical vs. Physical Address, 주소바인딩(Address Binding), Memory-Management Unit(MMU), Dynamic Relocation, Hadware Support for Address Translation, Some Treminologies, Dynamic Loading, Overlays, Swapping, Dynamic Linking, Allocation of Physical Memory, Contiguous Allocation, Paging</p>\n</blockquote>\n<h1>메모리와 주소</h1>\n<ul>\n<li>메모리는 주소를 통해 접근하는 매체이다.</li>\n<li>프로그램이 실행되면 독자적인 주소공간이 생성된다. 이때 프로그램마다 가지고 있는 주소를 논리적 주소(가상 주소)라고 한다.</li>\n<li>물리적 주소는 메모리의 어디에 프로그램이 올라가는지 그 물리적인 주소를 뜻한다.</li>\n<li>프로그램은 실행되려면 물리적인 메모리에 올라가야 하고, 이를 위해서는 주소가 결정되야 한다. 이때 주소를 결정하는 것을 주소 바인딩이라고 말한다.</li>\n</ul>\n<h3>주소의 구분 (2)</h3>\n<ul>\n<li><strong>1) 논리적 주소 Logical address == Virtual address</strong>\n<ul>\n<li>프로세스마다 독립적으로 가지는 주소 공간이다.</li>\n<li>각 프로세스마다 0번지부터 시작한다.</li>\n<li><strong>CPU 입장에서의 주소가 바로 Logical Address이다.</strong></li>\n</ul>\n</li>\n<li><strong>2) 물리적 주소</strong>\n<ul>\n<li>메모리에 실제로 올라가는 위치를 말한다.</li>\n</ul>\n</li>\n</ul>\n<h3>주소 바인딩 (주소 변환)</h3>\n<ul>\n<li>주소 바인딩이란, 프로그램이 물리적인 메모리의 어딘가로 올라가서 실행될 때, 그 <strong>주소를 결정하는 것이다.</strong></li>\n<li>이때, 이 주소는 언제 결정될까?\n<ul>\n<li>→ 3가지 결정 방법이 있다. 각각의 결정 방법에 따라 주소의 결정 시점이 다르다.</li>\n</ul>\n</li>\n</ul>\n<h3>Symbolic, Logical, Physical Address</h3>\n<ul>\n<li><strong>주소는 Symbolic binding → Logical Address → Physical Address 의 3단계를 거쳐 변환된다.</strong></li>\n<li><strong>(1) Symbolic address:</strong> 프로그래머의 입장에서, 사람이 프로그래밍을 할 때는 변수는 그 이름으로 저장하고, 그 이름으로 호출한다. 이를 “Symbolic Address”를 사용한다고 한다.</li>\n<li><strong>(2) Logical Address:</strong> Symbolic Address는 컴파일을 거쳐서 숫자로 된 주소가 된다.</li>\n<li><strong>(3) Physical Address:</strong> 실행되려 할 때 물리적인 메모리 위에 올라가야 하므로, 주소 변환이 이루어진다.</li>\n</ul>\n<h1>주소 바인딩 (Address Binding)</h1>\n<h3>주소 변환이 언제 일어나는가?</h3>\n<ul>\n<li><strong>1) Compile time binding</strong> - 컴파일할 때\n<ul>\n<li>컴파일 시에 메모리 주소가 결정되어 있으므로 항상 해당 위치에 올라가야 한다. 다른 주소가 비어도 해당 위치로밖에 갈 수 없으므로 매우 비효율적이며, 따라서 최근의 사용 빈도는 낮다.</li>\n<li>컴파일러는 absolute code(절대 코드)를 생성한다. 위치를 바꾸려면 컴파일을 새로 해야 한다.</li>\n</ul>\n</li>\n<li><strong>2) Load time binding</strong> - 실행이 시작될 때\n<ul>\n<li>컴파일 타임에는 논리적 주소까지만 결정된 상태에서, 프로그램이 메모리에 올라갈 때 주소가 결정된다.</li>\n<li>컴파일러는 relocatable code(재배치가능 코드) 를 생성한다.</li>\n</ul>\n</li>\n<li><strong>3) Execution time binding (Run time binding)</strong> - 프로그램 실행 중\n<ul>\n<li>프로그램이 실행된 중에도 메모리 위치가 바뀔 수 있다.\n<ul>\n<li>(예) 실행되는 도중에 메모리에서 쫓겨나고 다른 곳에 다시 올라갈 수 있다.</li>\n</ul>\n</li>\n<li>최근의 컴퓨터에서 지원</li>\n<li>relocatable code 재배치가능 코드</li>\n<li>메모리 위치 변화를 감지하고 그때그때 주소변환을 해주어야 하는데, 이때 MMU 의 도움을 받는다.</li>\n</ul>\n</li>\n</ul>\n<h3>CPU가 바라보는 주소는 논리적 주소이다.</h3>\n<ul>\n<li>CPU가 각각의 instruction 을 수행할 때, 메모리의 물리적인 주소에 올라가더라도 컴파일된 코드 각각은 논리적인 주소를 참조하고 있다.</li>\n</ul>\n<h1>Execution(Run) Time Binding</h1>\n<h3>Memory-Management Unit (MMU)</h3>\n<ul>\n<li>\n<p>런타임바인딩에서 실행 중 주소변환을 지원해주는 하드웨어</p>\n</li>\n<li>\n<p>논리적 주소를 → 물리적 주소로 매핑해주는 <strong>하드웨어 장치</strong>이다.</p>\n</li>\n<li>\n<p>2개의 레지스터를 활용한다. 운영체제 및 사용자 프로세스의 메모리 보호를 목적으로 한다.</p>\n<ul>\n<li>\n<ol>\n<li>Relocation(Base) Register: 접근 가능한 물리적 메모리 주소의 최소값으로, CPU에서 생성되는 모든 주소값에 대해 더해지는 값이다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>Limit Register: 논리적 주소의 범위</li>\n</ol>\n</li>\n<li>예시) 다른 프로세스의 메모리를 엿보려는 논리적 주소를 요청한다면 → 레지스터를 통해 조정을 거침으로써 해당 범위에 접근을 원천 차단할 수 있다.</li>\n<li>사용자 프로그램은 논리적인 주소만을 다루며, 물리적 주소를 볼 수 없고 알 필요가 없다.</li>\n</ul>\n</li>\n</ul>\n<h1>용어 정리</h1>\n<h3>Dynamic Loading</h3>\n<ul>\n<li>메모리에 프로세스 전체를 올리지 않고, 프로세스의 해당 루틴이 필요시에 메모리에 동적으로 올리는(loading) 것을 말한다.</li>\n<li>이를 통해 메모리 효율을 올릴 수 있다. 사용 빈도는 낮지만 양이 많은 경우에 매우 유용하게 쓸 수 있다.</li>\n<li>주로 프로그래머가 라이브러리를 이용해 구현한다. (운영체제가 페이징 기법에서 하는 것과 다르다.)</li>\n</ul>\n<h3>Overlays (Manual Overlay)</h3>\n<ul>\n<li>메모리에 프로세스에서 필요로 하는 정보만 올리는 기법이다.</li>\n<li>초창기에 프로그램을 메모리에 모두 올리지 못했을 당시 사용하던 방법으로, 다이나믹 로딩과 개념적으로는 유사하나, 프로그래머가 모두 수작업을 통해 코딩한 것을 오버레이라 한다. 운영체제의 지원 없이 구현하며, 코드가 매우 복잡하다.</li>\n<li>프로세스의 크기가 메모리보다 클 때 유용하다.</li>\n</ul>\n<h3>Swapping</h3>\n<ul>\n<li>프로세스를 일시적으로 메모리에서 backing store 로 완전히 (최근에는 일부 쫓아내는 것도 포함함) 쫓아내는 것을 말한다.</li>\n<li>효율적인 스와핑을 위해서는 런타임바인딩이 지원되는 것이 좋다.</li>\n</ul>\n<h3>Dynamic Linking</h3>\n<ul>\n<li>Static linking: 라이브러리가 실행 파일 코드에 포함된다.</li>\n<li>Dynamic linking: 라이브러리가 실행시 연결된다. 위치를 찾기 위한 stub 코드를 통해 라이브러리를 찾아서 메모리에 올려 실행되도록 한다. 이미 메모리에 있으면 그 주소로 간다.</li>\n</ul>\n<h1>물리적인 메모리의 관리</h1>\n<ul>\n<li>메모리의 낮은 주소영역은 OS 상주 영역, 높은 주소영역은 사용자 프로세스 영역이다.</li>\n<li>사용자 프로세스 영역에서의 할당 방법은 두 가지가 있다.\n<ul>\n<li>\n<ol>\n<li>Continuous allocation 연속할당</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>NonContinuous allocation 불연속할당</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Continuous allocation 연속할당</h1>\n<ul>\n<li>Fixed partition allocation 고정 분할: 크기가 맞는 분할 영역이 프로그램을 할당하는 것\n<ul>\n<li>internal fragmentation 내부조각 (할당되었지만 남는 공간), external fragmentation 외부조각 (좁아서 들어갈 수 없는 공간) 모두가 생길 수 있다.</li>\n</ul>\n</li>\n<li>Variable partition allocation 가변불할: 프로그램을 실행할 때마다 메모리에 올리는 것\n<ul>\n<li>실행과 종료에 의해 외부 조각이 생길 수 있다.</li>\n</ul>\n</li>\n<li>cf.) Hole: 가용(== 비어있는) 메모리 공간 → 산발적으로 발생한다.</li>\n</ul>\n<h3>Dynamic Storage-Allocation Problem</h3>\n<ul>\n<li>가변 불할 방식에서 가장 적절한 hole의 크기는 어떻게 찾을 수 있을까? (size == n일 때)</li>\n<li><strong>1) First-fit:</strong> 최초 (≥ n인 최초의 hole)</li>\n<li><strong>2) Best-fit:</strong> 최적 hole (≥ n인 hole 중 최소 → 정렬되지 않은 경우 탐색 필요)</li>\n<li><strong>3) Worst-fit:</strong> 가장 큰 hole (→ 정렬되지 않는 경우 탐색 필요)</li>\n<li>1, 2번이 시간, 공간복잡도상 효율적이다.</li>\n</ul>\n<h3>Compaction</h3>\n<ul>\n<li>외부조각을 최소화할 수 있는 방법으로, 메모리 영역과 hole 들을 각각 한 군데로 몰아서 (서로 반대 방향) 블럭을 만든다.</li>\n<li>비용이 많이 드는 방법이며, 최소한의 메모리 이동으로 해내야 하므로 매우 복잡하다. (전체 프로그램의 바인딩과 연관)</li>\n<li>런타임바인딩을 지원해야만 가능한 방법이다.</li>\n</ul>\n<h1>NonContinuous allocation 불연속할당</h1>\n<ul>\n<li>현대 시스템에서는 대부분 불연속할당을 사용하여, 앞서 발생했던 문제들로부터 비교적 자유로움</li>\n<li>크게 Paging, Segmentation의 두 가지로 나뉜다.</li>\n</ul>\n<h3>Paging</h3>\n<blockquote>\n<p>프로세스을 구성하는 주소공간을 동일한 사이즈의 page 로 나누는 기법</p>\n</blockquote>\n<ul>\n<li>주소공간 → “page” 프로그램을 구성하는 주소공간을 동일한 사이즈의 page 로 자른 것</li>\n<li>메모리 → “page frame” 물리적인 메모리를 page 단위로 자른 것</li>\n<li>이 page 단위로 물리적인 메모리에 올라가거나, backing store에 내려가게 된다.</li>\n<li>hole 크기의 불균일로 인한 external fragmentation 문제가 발생하지 않는다. (page의 배수가 아닐 수 있으므로 약간의 internal fragmentation 발생 가능성은 있으나, 영향력은 작다.)</li>\n<li>주소 바인딩: 잘려진 각각의 page 별로 주소공간을 바인딩해야 하므로 조금 더 복잡하다. (page table)</li>\n</ul>\n<h3>Segmentation</h3>\n<ul>\n<li>프로그램의 주소공간을 어떤 의미 단위로 자르는 것</li>\n<li>주소공간을 의미 단위 (ex. code segment, data segment, stack segment, 함수 등) 단위로 잘라서 각각의 segment가 필요할 때 물리적인 메모리의 다른 위치에 올려 놓을 수 있다.</li>\n<li>의미 단위로 잘랐으므로 크기가 균일하지 않다.</li>\n<li>Paged Segmentation</li>\n</ul>","frontmatter":{"title":"반효경 [운영체제] 18. Memory Management 1","date":"220415 Fri","description":""}},"previous":{"fields":{"slug":"/BOJ-1002/"},"frontmatter":{"title":"[boj] 1002. 터렛 (node.js)"}},"next":{"fields":{"slug":"/BOJ-21608/"},"frontmatter":{"title":"[boj] 21608. 상어 초등학교 (node.js)"}}},"pageContext":{"id":"380b914b-b278-5e80-b2ef-92e45fe1f7e1","previousPostId":"9c44b56e-65ef-5e9a-b381-57a87ec0e091","nextPostId":"fea3c2c0-b207-5b6d-8c13-ae4a1d5e528d"}},
    "staticQueryHashes": ["230163734","2841359383"]}