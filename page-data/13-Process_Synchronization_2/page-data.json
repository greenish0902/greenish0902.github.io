{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/13-Process_Synchronization_2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"1cb085f8-68fa-524d-bd0c-d74269095bf4","excerpt":"반효경 [운영체제] 13. Process Synchronization 2 Semaphores, Critical Section of n Processes, Block / Wakeup Implementation, Implementation, Two Types of Semaphores…","html":"<h1>반효경 [운영체제] 13. Process Synchronization 2</h1>\n<blockquote>\n<p>Semaphores, Critical Section of n Processes, Block / Wakeup Implementation, Implementation, Two Types of Semaphores, Deadlock and Starvation, Dining-Philosophers Problem</p>\n</blockquote>\n<h1>Semaphores</h1>\n<h2>추상 자료형</h2>\n<ul>\n<li>논리적으로 정의하여 구현하는 것과 별개의 개념</li>\n<li>추상화 연산을 정의해둔 것</li>\n</ul>\n<h2>Semaphore</h2>\n<ul>\n<li>역할: 공유 자원을 획득하고 반납하는 처리</li>\n<li>Semaphore 변수 S\n<ul>\n<li>정수값을 가질 수 있음</li>\n<li>변수값 == 자원의 개수</li>\n</ul>\n</li>\n<li>P, V 두 가지 연산을 정의\n<ul>\n<li>⇒ Critical Section 문제 해결에 P, V연산 응용</li>\n<li>Lock과 Unlock을 보다 간편하게 할 수 있음</li>\n</ul>\n</li>\n</ul>\n<h2>P 연산, V 연산</h2>\n<ul>\n<li>Critical Section 문제에 사용</li>\n<li><strong>P 연산:</strong> Semaphore 변수 (공유 데이터)를 획득, Lock</li>\n<li><strong>V 연산:</strong> 사용을 마치고 반납하는 과정, Unlock</li>\n<li>mutex (mutually exclusive) 변수를 1로 놓고 획득할 때 P연산 (lock) - 빠져나올 때는 V연산 (unlock)</li>\n</ul>\n<h2>연산</h2>\n<ul>\n<li>Busy Waiting (spin lock)</li>\n<li>Block &#x26; WakeUp (sleep lock)</li>\n</ul>\n<h3>busy waiting</h3>\n<ul>\n<li>atomic 하게 연산이 수행됨을 가정</li>\n<li>spin lock 현상</li>\n<li>busy-waiting 문제: 자원이 없으면 기다리다가 본인이 cpu 시간을 다 쓰고 반납</li>\n<li></li>\n<li>S: 자원의 개수</li>\n<li>추상 자료형이 제공, 프로그래머는 Semaphore을 통해 훨씬 간단하게 프로그래밍 가능</li>\n</ul>\n<h3>Block &#x26; Wakeup</h3>\n<ul>\n<li>Semaphore을 기다리며 block &#x26; wakeup</li>\n<li>V연산: 반납하고 + 깨워주는 것(ready)까지 수행</li>\n<li>Sleep Lock: 못 얻으면 sleep (blocked 상태)</li>\n<li><code class=\"language-text\">S.value</code> 자원의 여분이 있는지의 여부 파악: 깨워야 하는지의 여부 파악을 위해 변수 사용</li>\n</ul>\n<h3>비교</h3>\n<ul>\n<li>일반적으로 Block &#x26; WakeUp이 CPU 사용률 better</li>\n<li>유의: 오버헤드\n<ul>\n<li>Critical Section의 길이가\n<ul>\n<li>길면 while 문을 돌며 기다리는 busy-waiting 보다 block &#x26; wakeup이 better</li>\n<li>짧으면 큰 차이 없으므로 busy-waiting 사용 가능</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Semaphore 사용의 유의점</h1>\n<h2>Deadlock</h2>\n<ul>\n<li>획득해야 하는 Semaphore: S, Q 2개인 경우</li>\n<li>한 프로세스가 S를 얻고 CPU를 빼앗겼으나, 또 다른 프로세스가 Q를 얻고 S를 얻고자 하는 경우</li>\n<li>→ 양쪽 프로세스 모두 S와 Q를 획득한 상태에서 영원히 조건을 충족하지 못하는 <strong>Deadlock</strong></li>\n<li>해결\n<ul>\n<li>자원 획득의 순서 지정: 반드시 순차적 획득 (S→Q)만 가능하도록 설정</li>\n<li>작성시 프로그래머의 유의 필요</li>\n</ul>\n</li>\n</ul>\n<h2>Starvation</h2>\n<ul>\n<li>자원을 얻지 못하고 무한히 기다리는 현상</li>\n<li>Deadlock 도 일종의 Starvation,</li>\n<li>여기서의 Starvation은 특정 프로세스들 간 자원공유로 다른 프로세스는 영원히 자원을 얻지 못하는 경우</li>\n</ul>","frontmatter":{"title":"[KOCW] 운영체제 (반효경, 2014) - 13. Process Synchronization 2","date":"February 28, 2022","description":"Semaphores, busy-waiting, block & wakeup, deadlock, starvation"}},"previous":{"fields":{"slug":"/BOJ-21919/"},"frontmatter":{"title":"[boj] 21919. 소수 최소 공배수 (node.js)"}},"next":{"fields":{"slug":"/BOJ-3055/"},"frontmatter":{"title":"[boj] 3055. 탈출 (node.js)"}}},"pageContext":{"id":"1cb085f8-68fa-524d-bd0c-d74269095bf4","previousPostId":"b608fa49-b0fb-57cf-8c39-28ee50a9932a","nextPostId":"7c33dbd0-02ac-5b31-8757-302f55e24798"}},
    "staticQueryHashes": ["230163734","2841359383"]}