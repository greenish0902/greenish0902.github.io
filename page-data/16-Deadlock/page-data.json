{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/16-Deadlock/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"2cfc8700-036e-51cc-bdc1-d2da69a37cbf","excerpt":"교착상태(deadlock), The Deadlock Problem, Deadlock 발생의 4가지 조건, Resource-Allocation Graph(자원할당그래프), Deadlock Prevention, Deadlock의 처리 방법, Deadlock Avoidance…","html":"<blockquote>\n<p>교착상태(deadlock), The Deadlock Problem, Deadlock 발생의 4가지 조건, Resource-Allocation Graph(자원할당그래프), Deadlock Prevention, Deadlock의 처리 방법, Deadlock Avoidance, Resource Allocation Graph algorithm, Banker’s Algorithm, Example of Banker’s Algorithm</p>\n</blockquote>\n<h1>Deadlock</h1>\n<ul>\n<li>\n<p>deadlock == 교착상태</p>\n</li>\n<li>\n<p>예시: 컴퓨터 내에서 제한된 자원의 양에 의한 교착상태 발생</p>\n</li>\n<li>\n<p>일련의 프로세스들이 서로 가진 자원(Resource)을 기다리며 block 된 (잠들어 있는) 상태</p>\n<ul>\n<li>이 때 ‘자원’ 하드웨어, 소프트웨어 자원 모두를 포함함</li>\n<li>예시\n<ul>\n<li>프로세스가 하고자 하는 작업이 자원 2가지를 필요로 할 때, 서로 하나씩 가진 후 상대방이 가진 자원을 요구한다면 → 하드웨어 자원을 기다리는 Deadlock</li>\n<li>2개의 프로세스 간 Semaphore → 소프트웨어적 Deadlock</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 자원 사용</p>\n<ul>\n<li>요청 단계</li>\n<li>획득 단계</li>\n<li>사용 단계</li>\n<li>반납 단계</li>\n</ul>\n</li>\n<li>\n<p>데드락을 각 단계와 결합해서 파악 가능</p>\n</li>\n</ul>\n<h1>Deadlock 의 발생 조건 (4)</h1>\n<ul>\n<li>4가지 조건을 모두 만족해야 함. (이론적 조건)</li>\n</ul>\n<ol>\n<li><strong>Mutual Exclusion 상호 배제:</strong> 자원을 가지고 있는 동안은 독점적으로 사용함</li>\n<li><strong>No preemption 비선점:</strong> 자원을 빼앗기지 않음</li>\n<li><strong>Hold and wait 보유대기:</strong> 보유 자원을 놓지 않고 계속 가진 상태로 대기함</li>\n<li><strong>Circular wait 순환대기:</strong> 필요로 하는 자원들이 꼬리에 꼬리를 물고 사이클이 발생하는 것</li>\n</ol>\n<ul>\n<li>\n<p>4가지 조건 모두를 만족해야만 Deadlock이 발생한다.</p>\n</li>\n<li>\n<p>그래프로 Deadlock 파악하는 방법</p>\n<ul>\n<li>그래프에 사이클이 없으면 Deadlock 이 아니다!</li>\n<li><strong>그래프에 사이클이 있으면</strong>\n<ul>\n<li>자원 당 인스턴스가 하나씩밖에 없는데 사이클이 생겼다 → 무조건 데드락이 있다!</li>\n<li>자원 당 인스턴스가 여러 개 → 데드락일 수도 있고, 아닐 수도 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Deadlock 처리하는 방법 (4)</h1>\n<ul>\n<li>방법 1, 2: 발생을 미연에 방지하는 방법 (강한 처리)</li>\n<li>방법 3: 생기도록 두고, 시스템이 느려지면 Detection &#x26; Recovery</li>\n<li>방법 4: Ignorance - 아무 일도 하지 않음\n<ul>\n<li>현대적인 시스템에서는 오히려 미연에 방지하는 방법이 오버헤드가 더 큼 → ignorance 주로 사용</li>\n</ul>\n</li>\n</ul>\n<h2>01 Deadlock Prevention</h2>\n<ul>\n<li>데드락의 4가지 조건 중 하나를 원천 차단하여 데드락 발생을 방지함.</li>\n<li>조건 1. <strong>Mutual Exclusion</strong>: 차단 불가능함</li>\n<li>조건 2. <strong>Hold and Wait</strong>\n<ul>\n<li>해결 1: 프로세스가 시작될 때 필요로 하는 자원을 모두 할당받게끔 함. 단점은 자원의 비효율성</li>\n<li>방법 2: Hold and Wait - 하나씩 자원을 할당받으며, Wait 하는 경우는 이미 Hold 한 자원도 뱉어낸 다음 기다리도록 함</li>\n</ul>\n</li>\n<li>조건 3. <strong>No Preemption</strong>\n<ul>\n<li>자원을 빼앗아올 수 있도록 함</li>\n</ul>\n</li>\n<li>조건 4. <strong>Circular Wait</strong>\n<ul>\n<li>자원마다 순서를 정해서 낮은 번호부터 획득해야 높은 번호를 획득할 수 있도록 함</li>\n<li>데드락을 원천적으로 막을 수 있으나, 자원 이용률 저하, 시스템 전체 관점에서의 성능 저하 (Starvation)</li>\n</ul>\n</li>\n<li>생기지도 않을 데드락을 위해 제약조건을 두므로, 비효율적일 수밖에 없음</li>\n</ul>\n<h2>02 Deadlock Avoidance</h2>\n<ul>\n<li>Prevention &#x26; Avoidance 모두 강한 방지법\n<ul>\n<li>Deadlock Prevention: 데드락의 가능성이 전혀 없을때만 할당해주게 됨</li>\n<li>Deadlock Avoidance: 프로세스가 시작될 때 평생에 쓸 자원의 최대량을 미리 알고 있다고 가정(declare)하고 데드락을 피해가게 됨.</li>\n</ul>\n</li>\n<li>available 한 자원이 있더라도 데드락의 가능성이 있는 자원의 요청에 대해서는 주지 않음.</li>\n<li>Banker’s Algorithm\n<ul>\n<li>자원당 instance가 여러 개인 경우</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"반효경 [운영체제] 16. Deadlock 1","date":"220323 Wed","description":"Deadlock, Deadlock의 발생 조건, Deadlock의 처리: Prevention, Deadlock Avoidance"}},"previous":{"fields":{"slug":"/BOJ-node-js/BOJ-1912/"},"frontmatter":{"title":"[boj] 1912. 연속합 (node.js)"}},"next":{"fields":{"slug":"/BOJ-node-js/BOJ-2090/"},"frontmatter":{"title":"[boj] 2090. 조화평균 (node.js)"}}},"pageContext":{"id":"2cfc8700-036e-51cc-bdc1-d2da69a37cbf","previousPostId":"283ca832-d955-5bdd-b3a6-f3c55f8f04dc","nextPostId":"2dfcd4ca-d0bc-56a2-9db1-7824bc425fbe"}},
    "staticQueryHashes": ["230163734","2841359383"]}