{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Operating-System/11-CPU_Scheduling_2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"2b1705b9-a9b1-591b-8187-98bc619233f6","excerpt":"CPU-burst Time의 분포, Schedulling Algorithms, Round Robin(RR), Multilevel Queue, Multilevel Feedback Queue, Multi-Processor Scheduling, Real-time Scheduling…","html":"<blockquote>\n<p>CPU-burst Time의 분포, Schedulling Algorithms, Round Robin(RR), Multilevel Queue, Multilevel Feedback Queue, Multi-Processor Scheduling, Real-time Scheduling, Example of Non-Preemptive SJF, Thread Scheduling, Algorithm Evaluation, 39:12</p>\n</blockquote>\n<h1>복습</h1>\n<h3>Round Robbin (RR)</h3>\n<ul>\n<li>컴퓨터 시스템의 특성에 효율성 * 공정성을 모두 만족하는 스케줄링 방법\n<ul>\n<li>공정성: CPU 대기시간이 CPU 사용시간에 비례하는 경향\n<ul>\n<li>CPU 짧게 사용하는 I/O bound job 인 경우 q 내에서 원하는 만큼 쓰고 빠져나갈 수 있고,</li>\n<li>오래 사용하려는 프로세스는 그 길이에 비례하게 사용</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>프로세스의 context를 저장하고, 얻었을 때 다시 그 지점부터 작업을 재개할 수 있는 메커니즘 덕분</li>\n</ul>\n<h1>Ready Queue의 줄서기</h1>\n<ul>\n<li>앞서 배운 것은 한줄서기 기준.</li>\n<li>여러 줄로 줄서기 → multilevel queue, multilevel feedback queue</li>\n</ul>\n<h2>Multilevel Queue</h2>\n<ul>\n<li>프로세스의 줄서기는 우선순위가 5가지로 나뉨\n<ul>\n<li>system process - interactive processes (사람) - interactive editing process - batch process(cpu사용 긴) - student process순</li>\n</ul>\n</li>\n<li>마치 계급처럼, 영원히 출신에 따른 우선순위를 극복할 수 없음 (변동 X)\n<ul>\n<li>다소 차별적</li>\n</ul>\n</li>\n<li>그 줄에만 우선권을 주는가? → Starvation\n<ul>\n<li>starvation 방지: 줄별로 CPU 시간 나누기 (ex. 80%, 20%)</li>\n</ul>\n</li>\n<li>두줄서기, queue의 특징에 맞는 스케줄링 방법 채택\n<ul>\n<li>foreground: interactive job, RR</li>\n<li>background: batch (interaction X, CPU 오래 사용), FCFS</li>\n</ul>\n</li>\n<li>issue: 시간, 승격 기준, 어떤 우선순위에 할당?</li>\n</ul>\n<h2>Multilevel Feedback Queue</h2>\n<ul>\n<li>주어진 할당시간에 따른 강등 (queue: (quantum) 8 → 16 → FCFS)\n<ul>\n<li>시간 내에 끝나지 않으면 낮은 우선순위로 이동 → FCFS</li>\n<li>CPU 사용시간 짧은 프로세스에 우선순위를 주게 됨</li>\n</ul>\n</li>\n<li>미리 CPU 사용시간 예측 불필요</li>\n</ul>\n<h2>Multiple Processor Scheduling</h2>\n<ul>\n<li>CPU가 여러 개인 시스템</li>\n<li>Homonegeneous processor\n<ul>\n<li>queue에 한 줄로 세워서 프로세서가 꺼내가도록 함</li>\n</ul>\n</li>\n<li>Load sharing\n<ul>\n<li>프로세서의 부하를 적절히 공유</li>\n</ul>\n</li>\n<li>Symmetric Multiprocessing (SMP)\n<ul>\n<li>모든 CPU가 대등하므로 각 CPU가 알아서 스케줄링</li>\n</ul>\n</li>\n<li>Asymmetric multiprocessing\n<ul>\n<li>여러 개의 CPU중 하나가 전체적인 조정(역할 분배)을 담당, 나머지 CPU는 그에 따름</li>\n</ul>\n</li>\n</ul>\n<h2>Real-Time Scheduling</h2>\n<ul>\n<li>time sharing system, deadline 보장하는 것이 중요, 주기적인(periodic) 성격 등</li>\n<li>Hard real-time systems\n<ul>\n<li>deadline을 반드시 보장해야 함</li>\n</ul>\n</li>\n<li>Soft real-time systems\n<ul>\n<li>deadline 보장하지는 못하지만 타 CPU비해 우선순위를 높여줌</li>\n</ul>\n</li>\n</ul>\n<h2>Thread Scheduling</h2>\n<ul>\n<li>Local Scheduling\n<ul>\n<li>User Level Thread</li>\n<li>운영체제는 스레드의 존재를 모름. 프로세스 내부에서 어떤 스레드에 CPU를 줄지 결정</li>\n</ul>\n</li>\n<li>Global Scheduling\n<ul>\n<li>Kernel Level Thread</li>\n<li>프로세스 스케줄링하듯 운영체제가 알고리즘에 근거한 할당 결정</li>\n</ul>\n</li>\n</ul>\n<h1>알고리즘 평가 방법</h1>\n<ol>\n<li>Queing models\n<ul>\n<li>CPU에 프로세스가 도착하고 처리하는 도착율, 처리율 확률분포가 주어질 때</li>\n<li>수식계산 결과로 throughput(performance index)을 계산</li>\n</ul>\n</li>\n<li>Implementation 구현 &#x26; Measurement 성능 실측\n<ul>\n<li>실제 시스템에 구현하여 성능 측정</li>\n</ul>\n</li>\n<li>Simulation\n<ul>\n<li>입력: trace → 모의 실험</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"반효경 [운영체제] 11. CPU Scheduling 2","date":"220223 Wed","description":"CPU 스케줄링, Multilevel Queue, Algorithm Evaluation"}},"previous":{"fields":{"slug":"/Problem-Solving/BOJ-node-js/BOJ-1012/"},"frontmatter":{"title":"[boj] 1012. 유기농 배추 (node.js)"}},"next":{"fields":{"slug":"/Problem-Solving/BOJ-node-js/BOJ-1697/"},"frontmatter":{"title":"[boj] 1697. 숨바꼭질 (node.js)"}}},"pageContext":{"id":"2b1705b9-a9b1-591b-8187-98bc619233f6","previousPostId":"c18cad79-630d-5cb1-9db7-a33b15d608ee","nextPostId":"25e9adcc-69b4-5c33-88bb-dc53d1ed64b7"}},
    "staticQueryHashes": ["230163734","2841359383"]}