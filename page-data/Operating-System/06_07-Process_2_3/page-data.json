{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Operating-System/06_07-Process_2_3/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"74e00fca-6fa2-5933-8281-62d6912bb7db","excerpt":"복습 - 동기식 vs 비동기식 동기식 입출력 입출력 수행하는 동안 입출력을 요청한 프로세스가 입출력 끝날때까지 아무것도 하지 않고 기다려야 하면 동기식 입출력! 두 종류로 구분 CPU를 아무것도 하지 않지만 잡고서 입출력이 끝날 때까지 기다리는 상태 CPU…","html":"<h1>복습 - 동기식 vs 비동기식</h1>\n<h3>동기식 입출력</h3>\n<ul>\n<li>입출력 수행하는 동안 입출력을 요청한 프로세스가\n<ul>\n<li>입출력 끝날때까지 아무것도 하지 않고 기다려야 하면 <strong>동기식 입출력</strong>!</li>\n</ul>\n</li>\n<li>두 종류로 구분\n<ul>\n<li>\n<ol>\n<li>CPU를 아무것도 하지 않지만 잡고서 입출력이 끝날 때까지 기다리는 상태</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>CPU를 다른 프로세스에 넘겨주고 입출력이 끝날 때까지 기다리는 상태</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3>비동기식 입출력</h3>\n<ul>\n<li>사용자 프로세스의 입출력을 요청한 프로세스가 입출력이 진행되는 동안에</li>\n<li>해당 프로세스가 곧바로 CPU를 잡아서 instruction을 수행하면 <strong>비동기식 입출력</strong>!</li>\n</ul>\n<h3>기타</h3>\n<ul>\n<li>CPU를 잡는지는 중요하지 않음. instruction 수행 여부가 중요.</li>\n<li>즉, I/O를 요청한 프로세스가 요청 직후 일을 하는가? 가 Key!</li>\n</ul>\n<hr>\n<h1>오늘의 진도</h1>\n<blockquote>\n<p>동기식 입출력과 비동기식 입출력, 프로세스 스케줄링 큐의 모습,\nThread, Single and Multithreaded Processes, Benefits of Threads, Implemetation of Threads</p>\n</blockquote>\n<h2>스레드 (Thread)의 개념</h2>\n<ul>\n<li>thread: 프로세스 내부에 CPU 수행 단위가 여러 개인 것\n<ul>\n<li>프로세스는 code, data, stack으로 구성된 주소공간을 가지며</li>\n<li>process마다 만들어지는 주소공간, 운영체제 내부에 PCB(Program Counter Block)을 두고 프로세스를 관리함.</li>\n<li>프로세스마다 별도의 주소공간을 만드는 것은 메모리 낭비이므로 → 주소공간은 하나만 띄워놓고 현재 CPU가 코드의 어느 부분을 수행하고 있는가를 알 수 있도록 → 여러 개의 <strong>program counter</strong> 로 나타냄</li>\n<li>즉, 프로세스 하나에 CPU 수행단위를 여러 개 두는 개념!</li>\n</ul>\n</li>\n</ul>\n<h3>특징</h3>\n<ul>\n<li>스레드: CPU 수행의 단위</li>\n<li>lightweight process 라고도 부른다. &#x3C;-> heavyweight process (전통적 프로세스)</li>\n<li>스레드의 구성: program counter, register set, stack space</li>\n<li>공유하는 부분 (task): code, data, OS 자원</li>\n<li>즉, 프로세스 하나에서 주소공간, 코드, 데이터, 자원 등은 공유하고, CPU 수행과 관련된 program counter, register, stack는 각 스레드가 별개로 갖는다.\n<ul>\n<li>주소공간은 하나만 띄워놓고 현재 CPU가 코드의 어느 부분을 수행하고 있는가를 나타내는 program counter 여러개를 띄워놓는 방식 = 스레드를 활용해 효율화</li>\n</ul>\n</li>\n<li>정리\n<ul>\n<li>주소공간에서는 스레드마다 별도의 stack을 가지며</li>\n<li>PCB에서는 스레드마다 CPU 관련 정보인 프로그램 카운터, 레지스터를 별도로 가짐.</li>\n</ul>\n</li>\n</ul>\n<h3>장점</h3>\n<ol>\n<li><strong>빠른 응답성 Responsiveness</strong>\n<ul>\n<li>blocked 상태의 스레드가 있다면 다른 스레드가 먼저 보여질 수 있어 사용자는 결과를 더 빨리 보기 시작할 수 있다.</li>\n</ul>\n</li>\n<li><strong>자원 공유 &#x26; 메모리 효율성 Resource Sharing</strong>\n<ul>\n<li>같은 작업끼리는 묶어 프로세스화 → 각 메모리에 별도로 올리는 낭비를 절약</li>\n</ul>\n</li>\n<li><strong>경제성 Economy</strong>\n<ul>\n<li>프로세스 생성(creating)보다 switching의 오버헤드가 적음</li>\n<li>다중스레드의 혐력으로 throughout 높이기</li>\n</ul>\n</li>\n<li><strong>병렬 활용 Utilization of MP Architecture</strong>\n<ul>\n<li>여러 개의 CPU를 둘 수 있는 경우의 이점: 각 스레드를 서로 다른 CPU에서 병렬적으로 수행.</li>\n<li>각 연산을 독립적으로 수행하고 합쳐줌</li>\n</ul>\n</li>\n</ol>\n<h3>구현 방식</h3>\n<ul>\n<li>Kernel Thread: 프로세스 안에 스레드의 존재를 운영체제가 인지. 커널의 지원 O.</li>\n<li>User Thread: 라이브러리를 통해 지원, 프로세스 안에 여러개의 스레드가 있음을 운영체제가 알지 못함. 사용자 수준에서의 스레드 구현.</li>\n<li>cf. Realtime Thread: realtime 기능 지원</li>\n</ul>","frontmatter":{"title":"반효경 [운영체제] 6. Process2, 7. Process3","date":"220214 Mon","description":"Process: 문맥, 상태, 문맥 교환, 스케줄러"}},"previous":{"fields":{"slug":"/Problem-Solving/BOJ-node-js/BOJ-16472/"},"frontmatter":{"title":"[boj] 16472. 고냥이 (node.js)"}},"next":{"fields":{"slug":"/Problem-Solving/BOJ-node-js/BOJ-3273/"},"frontmatter":{"title":"[boj] 3273. 두 수의 합 (node.js)"}}},"pageContext":{"id":"74e00fca-6fa2-5933-8281-62d6912bb7db","previousPostId":"f3b1d475-b529-5813-945d-bd8c2168d04a","nextPostId":"9155fe28-2c73-5403-b341-ddd5675693ab"}},
    "staticQueryHashes": ["230163734","2841359383"]}