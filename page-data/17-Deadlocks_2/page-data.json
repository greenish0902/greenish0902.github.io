{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/17-Deadlocks_2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"70c85e62-fb94-51db-9c3b-0d3f2732aa0f","excerpt":"Deadlock의 처리 방법, Deadlock Avoidance, Example of Banker’s Algorithm, p1 request(1, 0, 2), Deadlock Detection and Recovery, Deadlock Ignorance Deadlock Avoidance…","html":"<blockquote>\n<p>Deadlock의 처리 방법, Deadlock Avoidance, Example of Banker’s Algorithm, p1 request(1, 0, 2), Deadlock Detection and Recovery, Deadlock Ignorance</p>\n</blockquote>\n<h1>Deadlock Avoidance</h1>\n<p>지난 수업에서 배운 Deadlock Preevention은 Deadlock을 사전에 막아 발생하지 않도록 하는 방법이다.</p>\n<p>이와 조금 다르게, Deadlock Aviodance는 사전에 정보를 통해 자원 할당 여부를 결정할 수 있다. 즉, 데드락이 발생하지 않음이 확실한 경우에만 자원을 할당해주는 방법이다.</p>\n<h3>Banker’s Algorithm</h3>\n<ul>\n<li>Banker’s Algorithm은 모든 프로세스에 대한 경우의 수를 판단한다. 할당된 자원과, 최대로 요구할 수 있는 자원의 양, 그리고 현재 가용 자원의 양 이 세 가지를 두고, 가용 자원으로 해당 프로세스의 요청이 처리 가능한 경우에만 자원을 할당해 준다.</li>\n<li>사전에 판단함으로써 절대 데드락이 생기지 않는 요청에 대해서만 받아들이는 보수적인 알고리즘이다.</li>\n</ul>\n<h3>Deadlock Avoidance</h3>\n<p>Deadlock Avoidance는 한 마디로 항상 Safe 한 상태를 유지하는 것이다. 현재 남아있는 자원으로 프로세스를 끝낼 수 있는 경우에만 프로세스에 자원을 할당해 준다!</p>\n<p><strong>safe sequence</strong></p>\n<ul>\n<li>요청과 반환이 계속될 때, 해당 시점의 가용 자원만으로 최대 요청을 처리할 수 있는 프로세스가 있는지 판단하고 → 요청을 처리할 수 있다고 판단되는 경우에만 해당 프로세스에게 자원을 할당해 준다.</li>\n<li>앞선 프로세스의 처리가 완료된 경우 돌아온 자원을 통해 다음 프로레스에 자원을 할당해줄 수 있는 연속적인 자원 할당을 말한다.</li>\n<li>적어도 하나의 전체적인 시퀀스가 존재한다면 “safe” 한 상태이다.</li>\n</ul>\n<h1>Deadlock Detection and Recovery</h1>\n<p>자원 당 인스턴스가 하나인 경우 → 사이클이 있으면 데드락이다.</p>\n<p>사이클을 찾기 위한 오버헤드는 O(n^2)가 소요된다.</p>\n<ul>\n<li>그래프상으로 생각해보면, 화살표가 나간다고 생각하면 n*(n-1)이므로 n^2에 수렴한다.</li>\n</ul>\n<h3>자원당 인스턴스가 여러 개인 경우</h3>\n<p>주어진 상황에서 데드락 발생 여부를 판단하고자 한다면?</p>\n<p>→ 낙관적인 접근으로 시작하기! (사용한 자원은 반납할 것이라고 가정)</p>\n<h3>데드락이 발견되면→ Recovery</h3>\n<ol>\n<li>Process termination\n<ol>\n<li>연루된 모든 프로세스를 한꺼번에 죽이는 방법</li>\n<li>데드락이 사라질 때까지 연루된 프로세스를 하나씩 죽이는 방법</li>\n</ol>\n</li>\n<li>데드락 발생에서 자원을 뺏는 패턴을 계속 바꿔주어야 함.\n<ol>\n<li>하나만 계속 희생하는 비용 최소화 프로세스는 마치 Starvation</li>\n</ol>\n</li>\n</ol>\n<h1>Deadlock Ignorance</h1>\n<p>데드락이 생기던 말던 가만히 놔두는 방법으로, 문제가 발생한다면, 사용자는 언젠가 이 문제를 인식하게 되므로 운영체제의 직접적 개입 없이, 사용자가 문제를 인식하고 처리하도록 할 수 있다.</p>","frontmatter":{"title":"반효경 [운영체제] 17. Deadlocks 2","date":"220407 Thu","description":"Deadlock Avoidance, Banker's Algorithm, Deadlock Detection and Recovery, Ignorance"}},"previous":{"fields":{"slug":"/BOJ-node-js/BOJ-7576/"},"frontmatter":{"title":"[boj] 7576. 토마토 (node.js)"}},"next":{"fields":{"slug":"/BOJ-node-js/BOJ-2661/"},"frontmatter":{"title":"[boj] 2661. 좋은수열 (node.js)"}}},"pageContext":{"id":"70c85e62-fb94-51db-9c3b-0d3f2732aa0f","previousPostId":"00f3ae94-3929-5b8f-9460-0f669493d460","nextPostId":"d0c0018b-c035-507a-90be-41ff425b3d93"}},
    "staticQueryHashes": ["230163734","2841359383"]}