{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/10-CPU_Scheduling_1/",
    "result": {"data":{"site":{"siteMetadata":{"title":"🧞‍♂️ Welcome to DEV.SH !"}},"markdownRemark":{"id":"afbd895b-1b5b-5e52-8d5c-59ce9652e5ab","excerpt":"CPU and I/O Bursts in Program Execution, CPU-burst Time의 분포, CPU Scheduler & Dispatcher, Scheduling Algorithms, Scheduling Criteria, FCFS(First- Come First…","html":"<blockquote>\n<p>CPU and I/O Bursts in Program Execution, CPU-burst Time의 분포, CPU Scheduler &#x26; Dispatcher, Scheduling Algorithms, Scheduling Criteria, FCFS(First- Come First-Served), SJF(Shortest-Job-First), Example of Non-Preemptive SJF, Example of Preemptive SJF, 다음 CPU Burst Time의 예측, Exponential Averaging, Priority Scheduling, Round Robin(RR), Example: RR with Time Quantum = 20, Turmaround Time Varies With Time Quantum</p>\n</blockquote>\n<h1>CPU Scheduling</h1>\n<h3>issues</h3>\n<ol>\n<li>CPU burst 에 들어온 (CPU 쓰고자 하는) 프로그램 중 누구에게 줄 것인가?</li>\n<li>CPU를 한 프로그램에게 계속 주느냐? 중간에 뺏어서 다른 프로세스에 넘겨주느냐?</li>\n</ol>\n<ul>\n<li>효율적인 mechanism</li>\n</ul>\n<h3>CPU 스케줄링 알고리즘</h3>\n<ol>\n<li><strong>Non-Preemtive 비선점형</strong>\n<ul>\n<li>강제로 빼앗지 않음. 쓰고 나갈때까지 (자진반납까지) CPU를 보장해주는 방법</li>\n</ul>\n</li>\n<li><strong>Preemtive 선점형</strong>\n<ul>\n<li>강제(timer interrupt 등) 현대 대부분의 CPU 스케줄링</li>\n</ul>\n</li>\n</ol>\n<h3>성능 척도 Peformance Measures(Index)</h3>\n<ul>\n<li><strong>시스템 입장</strong>\n<ul>\n<li>많은 일을 시키는 것을 추구</li>\n</ul>\n<ol>\n<li>CPU Utilization 이용률\n<ul>\n<li>전체 시간 중 CPU 가 일한 시간의 비율</li>\n<li>가능한 일을 오랫동안, 많이 하는 것을 추구</li>\n</ul>\n</li>\n<li>Throughput 산출량, 처리량\n<ul>\n<li>주어진 시간 내에 몇 개의 작업을 완료했느냐</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>고객 (프로세스) 입장</strong>\n<ul>\n<li>시간 중시</li>\n</ul>\n<ol>\n<li>Turn around time 반환시간, 소요시간\n<ul>\n<li>CPU 쓰러와서 줄 설때부터, IO후 다 쓰고 나갈때까지 걸린 시간</li>\n</ul>\n</li>\n<li>Waiting time 대기시간\n<ul>\n<li>순수하게 기다린 시간들의 총합(+=)</li>\n</ul>\n</li>\n<li>Response time 응답시간\n<ul>\n<li>ready-queue에 CPU를 쓰러 와서, <strong>처음으로(최초)</strong> CPU를 얻기까지 걸린 시간</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h1>스케줄링 알고리즘</h1>\n<h2>01 FCFS (First Come First Served)</h2>\n<ul>\n<li>선착순</li>\n<li>Waiting time 의 평균 시간이 앞의 프로세스의 소요시간에 영향을 많이 받는다.</li>\n<li><strong>Convoy Effect</strong> 발생\n<ul>\n<li>앞에 오래걸리는 프로세스가 오면, 짧은 시간이 걸리는 process 임에도 오래 기다려야 하는 효과</li>\n</ul>\n</li>\n</ul>\n<h2>02 SJF (Shortest Job First)</h2>\n<ul>\n<li>평균대기시간을 최소화할 수 있는 알고리즘</li>\n<li>FCFS에서 나타나는 문제점(convoy) → SJF (짧은 걸 먼저 오도록) → average waiting time 평균대기시간 최소화! (SJF is optimal(preemtive))</li>\n<li>분류\n<ul>\n<li><strong>Non-Preemtive</strong> (뺏지 않기): 더 짧은 프로세스가 도착해도 사용권 보장</li>\n<li><strong>Preemtive</strong> (강제 종료): : 더 짧은 프로세스가 도착하면 뺏김.\n<ul>\n<li>== SRTF (Shortest Remaining Time First): 남은 시간이 짧은 프로세스에게. ← 최소대기시간; <strong>optimal(minimum) case</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Preemtive ****문제점\n<ol>\n<li><strong>Starvation</strong>\n<ul>\n<li>사용시간이 길어 영원히 CPU를 잡지 못하는 프로세스가 있을 수 있다.</li>\n</ul>\n</li>\n<li><strong>CPU 사용시간을 미리 알 수 없다.</strong>\n<ul>\n<li>실제값을 알 수 없어 이론적인 알고리즘, 추정을 통한 예측값을 통해서만 SJF 사용이 가능하다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3>다음 CPU Burst time의 예측</h3>\n<p>예측을 위해 과거 데이터(직전, 그 이전의 CPU 사용시간 등)에 가중치를 적용하여 반영</p>\n<h2>03 Priority Scheduling</h2>\n<ul>\n<li>우선순위가 높은 Process 에게 CPU를 주는 알고리즘</li>\n<li>분류\n<ul>\n<li>Non-Preemtive 보장</li>\n<li>Preemtive 강제 종료</li>\n</ul>\n</li>\n<li>일반적으로 우선순위는 정수, 크기가 작을수록 높은 우선순위를 표현</li>\n<li>Problem: Starvation\n<ul>\n<li>Solution → Aging 기법\n<ul>\n<li>시간이 흐르면 우선순위를 높여주는 기법</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>04 Round Robbin</h2>\n<ul>\n<li>현대적인 컴퓨터 시스템의 스케줄링 방법</li>\n<li>사전에 할당된 시간, timer interrupt를 통해, preemtive (빼앗길 수 있는)</li>\n<li><strong>장점: 빠른 응답시간</strong>\n<ul>\n<li>누구든지 CPU 사용 가능</li>\n<li>굳이 예측할 필요 없이 CPU 사용시간 짧은 프로세스는 빨리 쓰고 나갈 수 있다.</li>\n</ul>\n</li>\n<li>특징\n<ul>\n<li>설정한 q (time unit)의 크기에 따라 응답시간이 매우 빨라질 수 있다.</li>\n<li>프로세스의 대기시간이 프로세스의 CPU 사용시간에 비례한다.</li>\n<li>일반적으로 SJF보다 average turnaround time이 길지만, response time은 더 짧다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[KOCW] 운영체제 (반효경, 2014) - 10. CPU Scheduling 1","date":"February 22, 2022","description":"CPU 스케줄링, 스케줄링 알고리즘"}},"previous":{"fields":{"slug":"/BOJ-1005/"},"frontmatter":{"title":"[boj] 1005. ACM Craft (node.js)"}},"next":null},"pageContext":{"id":"afbd895b-1b5b-5e52-8d5c-59ce9652e5ab","previousPostId":"21446780-5ff9-5e79-b5a0-6d5ee0ba3715","nextPostId":null}},
    "staticQueryHashes": ["230163734","2841359383"]}